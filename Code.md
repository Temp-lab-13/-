
## Массивы

>Инициализация массивов.

**Инициализация одномерноего массива** <br>
Где `length` - это задаваемая длина создаваемого массива.<br>
Получить длину уже готового массива так же можно через `имяМассива.Length`. <br>
А `int`, `string` и так длаее - это типы данных, которые хранит массив. типизация строгая, задаётся сразу при создании и не меняется.
```c#
int[] array = new int[length]; 

string[] array = new string[length];

double[] array = new double[length];
```
**Инициализация двумерного массива.**<br> 
Где `length` - задаваемый рамер массива задающий колличество строк, а `length2` - размер массива задающий колличество столбцов.(ну или длину этих строк)
```c#
int[,] array = new int[length, length2]; 
```
**Инициализация одномерного и двумерного массива** с ручным заполнением элементами сразу при создании этих массивов.
Длина массивов будет определена колличество записанных элементов и не может быть изменена после.
```c#
int[] array = {1 ,2, 3}; 
int[,] array = new int[,] {{1, 2}, {1, 2}};
```
Что бы обратиься к элементу в массиве.<br> 
**В одномерном массиве**, просто указывается индекс нужного элемента в скобках.<br> 
**В двумерном массиве**, сначало индекс строки, а потом индекс элемента в этой строке. Счёт индекса начинается с `0`.
```c#
array[0];
array[0, 0];
```
Быстрый способ **распечатать одномерный массив**, без использования циклов.
```c#
Console.Write(string.Join(" ", array));
```
Что бы **рапечатать двумерный массив** нужен двойной цикл.
Где `GetLength(0)` - получает длину массива(`array`) по колличеству строк, а `GetLength(1)` - получает длину по колличеству элементов в строке. <br>
`i` - задаёт индекс строки, а `j` - уже индекс элементов в этой строке.
```c#
for(int i = 0; i < array.GetLength(0); i++)
{
    for(int j = 0; j < array.GetLength(1); j++)
    {
        Console.Write($"{array[i, j]}");
    }
    Cosole.WriteLine();
}
```
## Random

> Инициализация класса рандом и генерация рандомного числа.


Создаёт отдельный экземпляр(`randomNumb`) класса `Random`, с помощью которого генерируется рандомное натуральное(целое) число, в заданном диапозоне от минимального `min` включительно до `max` не включительно(т.е. при значении max 100, генерация чисел будет до 99.).
```c#
Random randomNumb = new Random(); 
 int num = randomNumb.Next(min, max);
```
Всё тоже самое, но для вещественных(имеющих остаток - числа после запятой(0.432)) чисел.<br> 
Для ограничения колличества чисел после запятой, используется `Math.Round`, округляющий остаток по последенй заданной цифре. В примере это `3`. Т.е. 0.45670001, станет 0.457 <br> 
Умножение  на `100` позволяет сместить запятую в право и добавить рандомному числу  *положительных* целых чисел. т.е сгенерированное число 0.45648573 станет 45.648573. <br>
У `Math.Round` так же есть дополнительные модификаторы. Смотреть раздел с этим классом.
```c#
Random randomDoub = new Random(); 
 double num2 = Math.Round(randomDoub.NextDouble() * 100, 3);
```
Вариант генерации вещественных чисел, с возможностью расширения диапозона до *отрицательных* чисел.
`- 100` - нижняя граница в отрицательном диапазоне. При этом, `200`  всегда должно быть в два раза больше, вычитаемого числа.
В пирмере, диапозон целых чисел идёт от `-100` до `100`.
```c#
Random randomDoub = new Random(); 
 double num2 = Math.Round(randomDoub.NextDouble() * 200 - 100, 3);
```
Упрощённый вариант генерации наруральных(можно сделать и для вещественных по этому же шаблону) чисел, в заданном диапозоне.<br>
Идея в том, что бы обойтись без создания отдельного экземпляра класса.   
```c#
int num4 = new Random().Next(min, max);
```
## Ввод и вывод

> Ввод и поверка введённого значения.

Вводим число, новертируем в инт и проверяем, на то былали строка успешно конвертирована. 
Если не успешно (пользователь ввёл не цифры или не целочисленные значения), то отрабатывает цикл и запрашивает ввод по новой, пока не будет введено корректное значение.
```c#
while (int.TryParse(Console.ReadLine(), out int peremennaR) != true)
     {
         Console.Write("Введена не корректная длина массива. Попробуйте ещё раз: ");
     }
```

Простой способ вывести вещественное число с ограничение вещественной части. (с округлением)<br>
`:f` Способ ограничить колличество знаков после запятой, на выводе в консоль.<br>
Где `2` - это колличество знаков. $ - обязательно для форматирования выводимой Строки. 
```c#
Console.WriteLine($"{b:f2}"); 
```

Модификатор строки `.Format` Позволяет отфармотировать выводимое число.
Где `0` это число которое бужет добавляться перед значением `valur`.
А `d2` - это минмальное колличество разрядов которое должно содержать выводимое число.
Пример при значениее `0:d2`: 
`valur = 2`, выведеться на консоль `02`.
`valur = 12`, выведеться на консоль `12`.
```c#
Console.WriteLine(string.Format("{0:d2}", valur));
```
## Метод Math

> Метод Math.Round с модификатором нулевого округления.

Позволяет отбросить не нужные цифры после запятой, без округления последней цифры .

`test` - обрабатываемое число или переменная с этим числом.

`3` - колличество чимволов после запятой, после которых очставшиеся символы буду отброшены.

`MidpointRounding.ToZero` - модификатор, позволяющий отбрасывать не нужную вещественную часть, без округления по последней цифре.
```C#
Math.Round(test, 3, MidpointRounding.ToZero)
```
> Метод Math.Truncate

Возвращает только целые числа. Т.е. отбрасывает все значения после запятой, без округления.
```c#
double num3 = Math.Truncate(num2); 
```

> Метод Math.Log10

Быстрый способ получить длину числа. Через логорифм.
`num` - число.
```c#
int num = 1246;
int length = (int)Math.Log10(num) + 1; 
```

## string

> Функционал работы со строкой.

Модификатор `Replace` позволяет заменять указанный символ(в первых скобках) в строке, на другой(указанный во вторых скобках.)
```c#
string text = "Текст".Replace("символ", "символ");
```

## Class

Создание классов:
```C#
class Test //Сам класс
{
    //логика класса.
}
Test nameClass = new Test(); // Объявление класса вариант 1
Test nameClass2 = new(); // Можно опустить указание класса.
var nameClass3 = new Test(); // Использовать самоопределяющийся var, обязательно указание класса.
var nameClass4 = new Test() { поле1 = хначение, поле2 = значение, ит.д}; // создание с присвоением.
Test nameClass2 = new() { поле1 = хначение, поле2 = значение, ит.д}; // Альтернатива.

class Test2
{
    public string name = "Йо"; // Публичное поле, может быть считано и изменено, видно всем.
    public readonly string nameTwo = "Йоs"; // Тоже публичное поле, но доступное только для чтения.
    // Полю данного типа, может быть присвоено значение либо напрямую в классе, 
    // либо при его инициализации.
}

class Test3 // класс с конструктором. 
{
    // Есть поля, которые необходимо заполнять.
    public string Name;
    public readonly string nameTwo;

    // Конструктор определяет шаблок создания класса и требования к заполнению данными.
    // Класс имеющий конструктор, может быть создан исключительно по шаблону конструктора.
    // Конструкторов у класса может быть несколько.
    public Test3(string name, string name2){
        this.Name = name;
        this.nameTwo = name2;
        // Указатель this, указывает именно на оноименное поле класса.
        // Таким образом, поле класса и переменна-аргумент конструктора могут быть 
        // названы одинаково, но не произойдёт конфликта.
    } 
}
Test3 nameClass = new Test3("Name", "Имя"); // Инициализаия класса через конструктор.

// Параметр params, позволяет передовать неограниченное колличесвто параметров,
// такпим образом, можно заполнять массивы и другие коллекции,
// а так же работать в ситуации, когда колличество передоваемых парметров не известно
// и не может быть покрыто несколькими конструкторами.
class Test4
{
    // поля класса
    public string mother;
    public string father;
    public string[] children;
    // метод класса, который использует params, позволяяя добавить не ограниченное количество
    // детей.
    public void addFamily(Test4 father, Test4 mother, params Test4[] children)
    {
        this.mother = mother;
        this.father = father;
        this.children = children;
    }
}
Test4 pers = new Test4();
Test4 father = new Test4();
Test4 mother = new Test4();
Test4 son = new Test4();
Test4 daughter = new Test4();
pers.addFamily(father, mother, son, daughter); //в children будут записаны оба переданных параметра.
```
Параметры и модификаторы класса:
```C#
class seales Test5
{
    public sealed int Datas {get; set;};
    public sealed void Method()
    {
        // логика метода
    }
}
// Модификатор `this` позволяет Расширять типы, присваивая им новые методы. 
public static class Test6
{   // к типу стринг применяется раширение методом.
    public static string Reverse(this string str)
    {
        return new String(str.ToCharArray(.Revers(.ToAraay())));
    }
} 
// Вызов метода
    string a = "123";
    // Теперь, к переменным типа стринг можно применить наш метод.
    Console.WriteLine(a.Reverse); // 321

//  Параметр `partial` позволяет разделить один метод на части, причём, его части могут находиться
//  даже в разных файлах программы. Этот же способ применим и к методам.
partial class Program
{
    // Логика класса
}
partial class Program
{
    // Логика класса
}
```

## Collectoins

`ArrayList()`
Кололлекция не строгой тиизации(любой элемент становиться object). Можно записать не ограниченное колличество элементов либого типа. Из минусов, 
```C#
var list = new ArrayList(); // создание экземпляра коллекции.
list.add("")One; // добавление элементов в коллекцию.
list.add(1); // можно добавить элемент любого типа.
```

`BitArray`
Коллекция для хранения битовых масок(в основном). Может хранить в качестве элемента толко trye or false. 1/0 
```C#
var list = new BitArray(8, true); // создание экземпляра коллекции с хаполнение 8 элементами
// в состоянии true
```

## Delegate
Все делегаты унаследованы от системного типа System.Delegate.
Делегаты являются reference типами, и значение по умолчанию для них равняется null.

```C#
// Объявление Делегата
delegate тип Имя(параметры);

delegate void SomeDelegate(); //объявление делегата
SomeDelegate myDelegate = new SomeDelegate(); //объявление переменной типа SomeDelegate
SomeDelegate myDelegate2 = new SomeDelegate(метод0); // присовение переменной метода var1
SomeDelegate myDelegate3 = метод1; // присовение переменной метода var2
myDelegate3 += метод2; // добавление делегату ещё одного метода. Вызываться будут оба.
myDelegate3(); // последовательно(в порядке добавления) отработает и метод1 и метод2.
myDelegate2 + = myDelegate3; // Сложение делегата с делегатом. 
//Однако, не возможно складывать делагаты разных типов(классов).
myDelegate3 - = метод0; // Методы и делегаты можно так же и вычитать.

// Делегат можно объвлять за пределами класса. 
// Однако, переменные-делегаты должны принадлежать какому-либо классу, как и
// обычные переменные других типов. Делегаты как и классы поддерживают модификаторы доступа,
// которые можно указывать перед объявлением делегатов.
public delegate void SomeDelegate(); //объявление делегата

class MyClass
{
    public delegate void AnotherDelegate(); //объявление делегата
    private SomeDelegate myDelegate;//объявление
    public AnotherDelegate myDelegate2;// переменных делегата
}

// Делегаты могут принимать и возращать параметры.
delegate int SomeDelegate();
// Оданко, в случаи имеющихся у делеагта методов с возращением параметров,
// возращае6ние будет происходить только из последнего возращающего метода.
delegate void SomeDelegate(int name);


// Что бы получить список методов делегата:
myDelegate3.GetInvocationList();
// Что бы получить колличество методов делегата:
myDelegate3.GetInvocationList().Length();
// Что бы безопасно вызвать делегат, без страха попатсь на null и упасть с ошибкой:
myDelegate4?.Invoke("Йо"); // вызов делегата с передачей параметра.
// Что бы получить инфу о методах хранимых в делегате:
myDelegate4.Method;
// Что бы получить инфу о свойстве делегата:
myDelegate4.Target;
// Что бы создать делегат с обощённым методом:
delegate TResult MyDelegate<T, TResult>(T, x);

// Встроенные методы:
Acion<?> myDelegate = метод; //? - тип данных.
// Делегат работает только с void-методами. 
Func<?, ?> myDelegate = метод; // первый ? отправляемое значение, второе ? возращаемое; 
// Делегат работает с возращаемыми методами.
Predicate <?> myDelegate = метод; // ? передаваемое значение;
//Делегат принимает какое-то значение и возращает true or falsh;
```

## Лямбда-выражения


# Готовые конвтрукции

```C#
// Позволяет безопасно пройти по ArrayList, который может содержать разного типа значения
// и допустим, слоить сумму всех имеющихся в нём чисел, без ошибки.
// При этом, происходит приведение нереляционных данных к 0;  
foriach (var iTem in arrayList)
{
    sum += (iTem as int?) ?? 0;
}
```